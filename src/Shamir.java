import java.util.LinkedList;
import java.util.Arrays;
import java.util.Vector;
import java.math.BigInteger;
import java.io.Console;
import java.io.FileOutputStream;
import java.io.Writer;
import java.io.FileWriter;
import java.io.FileInputStream;
import java.io.DataInputStream;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.security.MessageDigest;
import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.CipherInputStream;
import java.io.IOException;
/**
 * This class includes methods that encrypt and decrypt files using Shamir Secret Sharing Scheme.
 * @author Albert Manuel Orozco Camacho - alorozco53
 * @version 11.5.30.13
 */
public class Shamir {
    
    protected int n, t;
    protected boolean crypt, decrypt;
    protected String evalCrypt, evalDecrypt, clear, crypted, algo1, algo2;
    
    /** Default constructor */
    public Shamir() {
	try {
	    this.n = -1;
	    this.t = -1;
	    this.crypt = false;
	    this.decrypt = false;
	    this.evalCrypt = "evaluations.frg";
	    this.evalDecrypt = "evaluations.frg";
	    this.algo1 = "AES";
	    this.algo2 = "SHA-256";
	} catch(Exception e) {
	    System.err.println(e);
	    System.exit(1);
	}
    }

    /**
     * Reads the parameters contained in args array
     * @param args -- array of parameters
     */
    public void readParams(String[] args) {
	if(args.length == 0) {
	    System.err.println("ERROR: Missing parameters.");
	    System.exit(1);
	}
	for(int i = 0; i < args.length; i++) {
	    try {
		switch(args[i]) {
		case "-c":
		    crypt = true; break;
		case "-d":
		    decrypt = true; break;
		case "-n":
		    n = Integer.parseInt(args[i+1]); break;
		case "-t":
		    t = Integer.parseInt(args[i+1]); break;
		case "-clear":
		    clear = args[i+1]; break;
		case "-crypted":
		    crypted = args[i+1]; break;
		case "-evalcr":
		    evalCrypt = args[i+1]; break;
		case "-evaldec":
		    evalDecrypt = args[i+1]; break;
		default: break;
		}
	    } catch(Exception e) {
		System.err.println("ERROR: Incorrect or missing parameter.");
		System.exit(1);
	    }
	}
	if(!crypt && !decrypt) {
	    System.err.println("ERROR: Missing crypt/decrypt indicating parameter.");
	    System.exit(1);
	}
	if(crypt) {
	    if(clear == null) {
		System.err.println("ERROR: Missing clear file name.");
		System.exit(1);
	    }
	}
	if(decrypt) {
	    if(crypted == null) {
		System.err.println("ERROR: Missing crypted file name.");
		System.exit(1);
	    }
	}
    }
    /**
     * Creates the fragmented file with n evaluations of the t-1 degree polynomial.
     * Then, it writes the file as evalCrypt.frg
     * @param polynomial -- vector array with the n evaluations
     */
    public void createFrag(Vector[] polynomial) {
	Writer wr;
	try {
	    wr = new FileWriter(evalCrypt,true);
	    for(int i = 0; i < polynomial.length; i++)
		wr.write(polynomial[i].elementAt(0).toString()+","+polynomial[i].elementAt(1).toString()+"\n");
	    wr.close();
	    System.out.println("The "+n+" evaluations of the polynomial were saved in "+evalCrypt);
	} catch(Exception e) {
	    System.err.println(e);
	    System.exit(1);
	}
    }

    /**
     * Encrypts the clear file using a secret key generated by the passwd byte array.
     * Then, it writes the encrypted file as clear.aes
     * @param passwd -- byte representation of the given password
     */
    public void encrypt(byte[] passwd) {
	int toWrite;
	String fileName;
	CipherInputStream ci;
	FileOutputStream wr; 
	SecretKeySpec sec;
	Cipher cipher;
	try {
	    if(clear.lastIndexOf('.') == -1)
		fileName = clear+".aes";
	    else
		fileName = clear.substring(0,clear.lastIndexOf('.'))+".aes";
	    cipher = Cipher.getInstance(algo1);
	    wr = new FileOutputStream(fileName,true);
	    sec = new SecretKeySpec(passwd,algo1);
	    cipher.init(Cipher.ENCRYPT_MODE,sec);
	    ci = new CipherInputStream(new FileInputStream(clear),cipher);
	    while((toWrite=ci.read()) != -1)
		wr.write(toWrite);
	    wr.close();
	    ci.close();
	    System.out.println("The encrypted file was saved as: "+fileName);
	} catch(Exception e) {
	    System.err.println(e);
	    System.exit(1);
	}
    }

    /**
     * Returns the byte representation of a user's password
     * @return byte[] -- representation of a password
     */
    public byte[] getPassword() {
	char[] passwd;
	byte[] bytes = null;
	Console cons;
	MessageDigest md;
	try {
	    if ((cons=System.console())!=null && (passwd=cons.readPassword("[%s]","Password:"))!=null) {
		md = MessageDigest.getInstance(algo2);
		bytes = md.digest(new String(passwd).getBytes());
		Arrays.fill(passwd, ' ');
	    }
	} catch(Exception e) {
	    System.err.println(e);
	    System.exit(1);
	}
	System.out.println("byte.len "+bytes.length);
	return bytes;
    }
    
    /**
     * Reads the evalDerypt file.
     * Returns the byte representation of an encrypted password, by using Lagrange interpolating polynomial evaluated in 0.
     * @return byte[] -- byte representation of the f(0) = K BigInteger, that is indeed, the password.
     */
    public byte[] getK() {
	Vector[] array = null;
	byte[] array1 = null;
	MessageDigest md;
	LinkedList<Vector> list = new LinkedList<Vector>();
	Zp zp = new Zp();
       	try {
            String strLine;
            FileInputStream fstream = new FileInputStream(evalDecrypt);
            DataInputStream in = new DataInputStream(fstream);
            BufferedReader br = new BufferedReader(new InputStreamReader(in));
	    System.out.println("Reading "+evalDecrypt+"...");
            while((strLine=br.readLine()) != null) {
		list.add(new Vector(2));
		((Vector)list.getLast()).add(0,new BigInteger(strLine.substring(0,strLine.indexOf(','))));
		((Vector)list.getLast()).add(1,new BigInteger(strLine.substring(strLine.indexOf(',')+1,strLine.length())));
            }
	    in.close();
	    array = new Vector[list.size()];
	    for(int i = 0; i < array.length; i++)
		array[i] = (Vector)list.get(i);
	    System.out.println("Evaluating Lagrange interpolating polynomial...");
	    return zp.lagrange(new BigInteger("0"),array).toByteArray();
        } catch (Exception e) {
            System.err.println(e);
            System.exit(1);
	}
	return null;
    }

    /**
     * Creates the clear file using a password (in bytes) and the crypted file
     * @param passwd -- the byte representation of a password
     */	
    public void createClear(byte[] passwd) {
	int toWrite;
	String fileName;
	CipherInputStream ci;
	FileOutputStream wr; 
	SecretKeySpec sec;
	Cipher cipher;
	try {
	    if(crypted.lastIndexOf('.') == -1)
		fileName = crypted;
	    else
		fileName = crypted.substring(0,crypted.lastIndexOf('.'));
	    cipher = Cipher.getInstance(algo1);
	    wr = new FileOutputStream(fileName,true);
	    sec = new SecretKeySpec(passwd,algo1);
	    cipher.init(Cipher.DECRYPT_MODE,sec);
	    ci = new CipherInputStream(new FileInputStream(crypted),cipher);
	    while((toWrite=ci.read()) != -1)
		wr.write(toWrite);
	    wr.close();
	    ci.close();
	    System.out.println("The clear file was saved as "+fileName);
	} catch(Exception e) {
	    System.err.println(e);
	    System.exit(1);
	}
    }

    /** 
     * Main method
     * @param args -- the program arguments
     */
    public static void main(String[] args) {
	byte[] passwd;
	Shamir sh = new Shamir();
	Zp zp = new Zp();
	sh.readParams(args);
	if(sh.crypt) {
	    System.out.println("Encrypting "+sh.clear+"...");
	    passwd = new BigInteger(sh.getPassword()).abs().toByteArray();
	    System.out.println("Generating SHA-256 hash code...");
	    sh.encrypt(passwd);
	    System.out.println("Creating file with "+sh.n+" evaluations...");
	    sh.createFrag(zp.crypt(new BigInteger(passwd).mod(zp.getPrime()),sh.t,sh.n));
	}
	if(sh.decrypt) {
	    System.out.println("Decrypting "+sh.crypted+"...");
	    passwd = sh.getK();
	    System.out.println("Creating clear file...");
	    sh.createClear(passwd);
	}
	System.exit(0);
    }
}